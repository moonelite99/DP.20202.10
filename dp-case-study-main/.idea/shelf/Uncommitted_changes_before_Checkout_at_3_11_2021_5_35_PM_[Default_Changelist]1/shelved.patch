Index: src/main/java/utils/MyMap.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package utils;\r\n\r\nimport java.lang.reflect.Field;\r\nimport java.util.*;\r\n\r\n/**\r\n * The {@link MyMap JSON} class represents JSON objects.\r\n * To create a new JSON object,\r\n * JSON jsonObject = new JSON();\r\n * jsonObject.put(\"key\", value);\r\n * \r\n * @author hieud\r\n *\r\n */\r\npublic class MyMap extends LinkedHashMap<String, Object> {\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\t/**\r\n\t * Return a {@link String String} that represents the JSON object.\r\n\t * \r\n\t * @author hieudm\r\n\t *         https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/Hashtable.java\r\n\t * @return a {@link String String}.\r\n\t */\r\n\tpublic String toJSON() {\r\n\t\tint max = size() - 1;\r\n\t\tif (max == -1)\r\n\t\t\treturn \"{}\";\r\n\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tIterator<Map.Entry<String, Object>> it = entrySet().iterator();\r\n\r\n\t\tsb.append('{');\r\n\t\tfor (int i = 0;; i++) {\r\n\t\t\tMap.Entry<String, Object> e = it.next();\r\n\t\t\tString key = e.getKey();\r\n\t\t\tObject value = e.getValue();\r\n\t\t\tsb.append('\"' + key.toString() + '\"');\r\n\t\t\tsb.append(':');\r\n\t\t\tsb.append(value instanceof MyMap ? ((MyMap) value).toJSON() : ('\"' + value.toString() + '\"'));\r\n\r\n//\t\t\tif (value instanceof MyMap) {\r\n//\t\t\t\tsb.append(((MyMap) value).toJSON());\r\n//\t\t\t} else {\r\n//\t\t\t\tsb.append('\"' + value.toString() + '\"');\r\n//\t\t\t}\r\n\t\t\tif (i == max)\r\n\t\t\t\treturn sb.append('}').toString();\r\n\t\t\tsb.append(\",\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Return a {@link Map Map} that represents the mapping among\r\n\t * attribute names and their values of an object.\r\n\t * \r\n\t * @author hieudm\r\n\t *         https://stackoverflow.com/questions/52406467/convert-object-to-map-in-java\r\n\t * @param obj - an arbitrary {@link Object Object}.\r\n\t * @return a {@link Map Map} mapping the attribute names and its\r\n\t *         values.\r\n\t * @throws IllegalAccessException\r\n\t * @throws IllegalArgumentException\r\n\t */\r\n\tpublic static Map<String, Object> toMyMap(Object obj) throws IllegalArgumentException, IllegalAccessException {\r\n\t\tMap<String, Object> map = new MyMap();\r\n\t\tList<Field> fields = new ArrayList<>();\r\n\t\tfields.addAll(Arrays.asList(obj.getClass().getDeclaredFields()));\r\n\t\tfields.addAll(Arrays.asList(obj.getClass().getSuperclass().getDeclaredFields()));\r\n\r\n\t\tfor (Field field : fields) {\r\n\t\t\tfield.setAccessible(true);\r\n\t\t\tObject value = field.get(obj);\r\n\t\t\ttry {\r\n\t\t\t\tif (!value.getClass().getPackage().getName().startsWith(\"java\")) {\r\n\t\t\t\t\tvalue = MyMap.toMyMap(value).toString();\r\n\t\t\t\t}\r\n\t\t\t} catch (Exception ex) {\r\n\t\t\t\t;\r\n\t\t\t}\r\n\t\t\tmap.put(field.getName(), value);\r\n\t\t\tfield.setAccessible(false);\r\n\t\t}\r\n\t\treturn map;\r\n\t}\r\n\r\n\tprivate static int offset = 0; // to trace the current index when calling a function\r\n\r\n\t/**\r\n\t * Return a {@link String String} that represents the term in between\r\n\t * 2 double quote.\r\n\t * \r\n\t * @author hieudm\r\n\t * @param \r\n\t * str - {@link String String}\r\n\t * idx - the index of the open quote\r\n\t * @return the term as {@link String String}\r\n\t * @throws IllegalArgumentException\r\n\t */\r\n\tprivate static String getNextTerm(String str, int idx) {\r\n\t\tif (str == null || idx >= str.length() || str.charAt(idx) != '\"') {\r\n\t\t\tthrow new IllegalArgumentException(\"Cannot resolve the input.\");\r\n\t\t}\r\n\r\n\t\tif (str.charAt(idx + 1) == '\"') {\r\n\t\t\treturn new String();\r\n\t\t}\r\n\r\n\t\tint i = idx + 1;\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tdo {\r\n\t\t\tsb.append(str.charAt(i));\r\n\t\t\ti++;\r\n\t\t\tif (i == str.length()) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"Cannot resolve the input.\");\r\n\t\t\t}\r\n\t\t} while (str.charAt(i) != '\"');\r\n\r\n\t\tString result = sb.toString();\r\n\t\toffset = result.length() + 2; // update iterator with the term and the 2 double quotes\r\n\t\treturn sb.toString();\r\n\t}\r\n\t/**\r\n\t * Return a {@link MyMap MyMap} that represents the interested substring in a {@link String String}.\r\n\t * \r\n\t * @author hieudm\r\n\t * @param \r\n\t * str - {@link String String}\r\n\t * idx - the index of the first character in the interested substring in the {@link String String}\r\n\t * @return the term as {@link MyMap MyMap}\r\n\t * @throws IllegalArgumentException\r\n\t */\r\n\tpublic static MyMap toMyMap(String str, int idx) throws IllegalArgumentException {\r\n\t\tif (str == null || str.length() < 2 || str.charAt(idx) != '{') {\r\n\t\t\tthrow new IllegalArgumentException(\"Cannot resolve the input.\");\r\n\t\t} else if (idx >= str.length()) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tMyMap root = new MyMap();\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tint i = idx;\r\n\t\tsb.append(str.charAt(i));\r\n\r\n\t\ti++;\r\n\t\ttry {\r\n\t\t\twhile (true) {\r\n\t\t\t\t// open quote\r\n\t\t\t\tif (str.charAt(i) != '\"') {\r\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot resolve the input.\");\r\n\t\t\t\t}\r\n\t\t\t\t// get key\r\n\t\t\t\tString key;\r\n\t\t\t\ttry {\r\n\t\t\t\t\tkey = getNextTerm(str, i);\r\n\t\t\t\t} catch (Exception ex) {\r\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot resolve the input.\");\r\n\t\t\t\t}\r\n\t\t\t\tif (key == null) {\r\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot resolve the input.\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsb.append(str.subSequence(i, i + offset));\r\n\r\n\t\t\t\ti += offset;\r\n\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t// check colon\r\n\t\t\t\tsb.append(str.charAt(i));\r\n\t\t\t\tif (str.charAt(i) != ':') {\r\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot resolve the input.\");\r\n\t\t\t\t}\r\n\t\t\t\ti++;\r\n\t\t\t\t// get value\r\n\t\t\t\tObject value;\r\n\t\t\t\tif (str.charAt(i) == '{') {\r\n\t\t\t\t\tvalue = toMyMap(str, i);\r\n\t\t\t\t\tsb.append(str.subSequence(i, i + offset));\r\n\t\t\t\t\ti += offset;\r\n\t\t\t\t\toffset = 0;\r\n\t\t\t\t} else if (str.charAt(i) == '\"') {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tvalue = getNextTerm(str, i);\r\n\t\t\t\t\t} catch (Exception ex) {\r\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot resolve the input.\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (value == null) {\r\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot resolve the input.\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsb.append(str.subSequence(i, i + offset));\r\n\t\t\t\t\ti += offset;\r\n\t\t\t\t\toffset = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot resolve the input.\");\r\n\t\t\t\t}\r\n\t\t\t\t//\r\n\t\t\t\troot.put(key, value);\r\n\t\t\t\tif (str.charAt(i) == ',') {\r\n\t\t\t\t\tsb.append(str.charAt(i));\r\n\t\t\t\t\ti++;\r\n\t\t\t\t} else if (str.charAt(i) == '}') {\r\n\t\t\t\t\tsb.append(str.charAt(i));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new IllegalArgumentException(\"Cannot resolve the input.\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\toffset = sb.toString().length();\r\n\t\t} catch (Exception e) {\r\n\t\t\te.printStackTrace();\r\n\t\t\tthrow new IllegalArgumentException(\"Cannot resolve the input.\");\r\n\t\t}\r\n\t\treturn root;\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/utils/MyMap.java b/src/main/java/utils/MyMap.java
--- a/src/main/java/utils/MyMap.java	
+++ b/src/main/java/utils/MyMap.java	
@@ -22,6 +22,10 @@
 	 *         https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/Hashtable.java
 	 * @return a {@link String String}.
 	 */
+
+/*
+/  logical cohesion vì phương thức
+ */
 	public String toJSON() {
 		int max = size() - 1;
 		if (max == -1)
